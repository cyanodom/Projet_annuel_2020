package steinerGraphJava.graph;

import java.io.File;
import java.io.Serializable;
import java.util.Hashtable;
import java.util.LinkedList;

import steinerGraphJava.graph.graphFile.Translator;

public class Graph implements IGraph, Serializable {
	
	// ATTRIBUTS
	
	private int maxTerminalNodeId;
	private LinkedList<Arc> shape;
	private Node[] nodes;
	private Hashtable<Node, String> userAssociatedNodeNames;
	
	// CONSTRUCTEUR
	
	public Graph() {
		userAssociatedNodeNames = new Hashtable<Node, String>();
		maxTerminalNodeId = 0;
		shape = new LinkedList<Arc>();
		nodes = new Node[0];
	}
	
	
	// REQUETES
	
	@Override
	public Node[] getNodes() {
		return nodes;
	}
	
	@Override
	public LinkedList<Arc> getShape() {
		return shape;
	}
	
	@Override
	public int getMaxTerminalNodeId() {
		return maxTerminalNodeId;
	}
	
	@Override
	public Hashtable<Node, String> getUserAssociatedNodeNames() {
		return userAssociatedNodeNames;
	}
	
	
	// COMMANDES
	
	@Override
	public void removeNode(Node n) {
		int j = 0;
		for (int i = 0; i < shape.size(); ++i) {
			if (shape.get(i - j).getNodes()[0].getName() == n.getName() || shape.get(i - j).getNodes()[1].getName() == n.getName()) {
				shape.remove(i - j);
				j++;
			}
		}
	}
	
	//REMOVE
	@Override
	public void addData(int length, Node[] nodeTab) {
		maxTerminalNodeId = length;
		nodes = nodeTab;
	}
	
	@Override
	public void addTerminalNode(String nodeName) throws GraphException {
		insertNode(maxTerminalNodeId + 1, nodeName);
	}
	
	private void insertNode(int node, String name) throws GraphException {
		if (userAssociatedNodeNames.containsValue(name)) {
			throw new GraphException("Ce noeud ne peut être ajouté : il est déja présent !");
		}
		Node[] new_nodes = new Node[nodes.length + 1];
		
		if (node == nodes.length) {
			new_nodes[nodes.length] = new Node(node);
			nodes = new_nodes;
			userAssociatedNodeNames.put(new_nodes[nodes.length], name);
			return;
		}

		int j = 0;
		for (int i = 0; i < nodes.length; ++i) {
			if (i != node) {
				new_nodes[j] = nodes[i];
			} else {
				new_nodes[j] = new Node(node);
				new_nodes[nodes.length] = new Node(nodes.length);
				String backup_name = userAssociatedNodeNames.get(new Node(j));
				userAssociatedNodeNames.remove(new Node(j));
				userAssociatedNodeNames.put(new_nodes[nodes.length], name);
				userAssociatedNodeNames.put(new Node(nodes.length), backup_name);
			}
			j++;
		}
		
		nodes = new_nodes;
	}
	
	@Override
	public void addNode(String nodeName) throws GraphException {
		insertNode(nodes.length, nodeName);
	}
	
	public void changeShape(LinkedList<Arc> shape) {
		this.shape = shape;
	}
	
	@Override
	public String convertNodeToName(Node node) {
		return userAssociatedNodeNames.get(node);
	}
	
	@Override
	public Node convertNameToNode(String name) {
		for (Node n : userAssociatedNodeNames.keySet()) {
			if (userAssociatedNodeNames.get(n) == name) {
				return n;
			}
		}
		return null;
	}

	@Override
	public LinkedList<String> getIntersectionWith(Graph graph) {
		LinkedList<String> result = new LinkedList<String>();
		for (int i = 0; i <= maxTerminalNodeId; ++i) {
			for (int j = 0; j <= graph.getMaxTerminalNodeId(); ++j) {
				if (graph.convertNodeToName(new Node (j)) == convertNodeToName(new Node(i))) {
					result.add(convertNodeToName(new Node(i)));
				}
			}
		}
		for (int i = maxTerminalNodeId + 1; i < nodes.length; ++i) {
			for (int j = graph.getMaxTerminalNodeId() + 1; j < graph.getShape().size(); ++j) {
				if (graph.convertNodeToName(new Node (j)) == convertNodeToName(new Node(i))) {
					result.add(convertNodeToName(new Node(i)));
				}
			}
		}
		return result;
	}

	@Override
	public void makeUnionWith(IGraph iGraph) throws GraphException {
		for (int i = 0; i < iGraph.getShape().size(); ++i) {
			if (i <= iGraph.getMaxTerminalNodeId()) {
				addTerminalNode(iGraph.convertNodeToName(iGraph.getNodes()[i]));
			} else {
				addNode(iGraph.convertNodeToName(iGraph.getNodes()[i]));
			}
		}
	}


	public void makeRemove(IGraph trans) {
		// TODO Auto-generated method stub
		
	}


	public void empty() {
		userAssociatedNodeNames = new Hashtable<Node, String>();
		nodes = new Node[0];
	}
	
}
